#!/bin/sh

# Make links to system files if they don't exist in /opt/etc
[ ! -f /opt/etc/hosts ] && [ -f /etc/hosts ] && ln -s /etc/hosts /opt/etc/hosts
[ ! -f /opt/etc/ethers ] && [ -f /etc/ethers ] && ln -s /etc/ethers /opt/etc/ethers
[ ! -f /opt/etc/resolv.conf ] && [ -f /etc/resolv.conf ] && ln -s /etc/resolv.conf /opt/etc/resolv.conf

# Check if this is an interactive console session
STDIN_FD="$(readlink -f /proc/$$/fd/0 2> /dev/null)"
[ -n "$STDIN_FD" ] && [ "$STDIN_FD" != "/dev/null" ] && INTERACTIVE=y

# Some of these commands might be missing depending on the system
# so we check if they exist and then prompt the user to install them
COMMAND_DEPS="su:shadow-su setcap:libcap-bin killall:psmisc pgrep:procps-ng-pgrep tput:libncurses-dev rev lscpu"
COREUTILS_DEPS="basename cat chmod chown cp cut date df dirname echo expr false head id install kill ln ls mkdir mktemp mv nohup printf pwd rm sha1sum sleep stat stty tail tee test timeout touch tr true tty uptime whoami"

CHECK_COMMAND=""
type 2> /dev/null && CHECK_COMMAND="type"
which --help > /dev/null 2>&1 && CHECK_COMMAND="which"

if [ -n "$CHECK_COMMAND" ]; then
    MISSING_CMDS=""
    MISSING_PKGS=""

    for COMMAND in $COMMAND_DEPS; do
        if echo "$COMMAND" | grep -q ":"; then
            PACKAGE="$(echo "$COMMAND" | cut -d ':' -f 2 2> /dev/null)"
            COMMAND="$(echo "$COMMAND" | cut -d ':' -f 1 2> /dev/null)"

            echo "$COMMAND" | grep -q ":" && continue # no 'cut' command?
        else
            PACKAGE="$COMMAND"
        fi

        #shellcheck disable=SC2086
        if ! $CHECK_COMMAND $COMMAND > /dev/null 2>&1; then
            MISSING_CMDS="$MISSING_CMDS $COMMAND"
            MISSING_PKGS="$MISSING_PKGS $PACKAGE"
        fi
    done

    for COMMAND in $COREUTILS_DEPS; do
        #shellcheck disable=SC2086
        if ! $CHECK_COMMAND $COMMAND > /dev/null 2>&1; then
            MISSING_CMDS="$MISSING_CMDS $COMMAND"
            MISSING_PKGS="$MISSING_PKGS coreutils-$COMMAND"
        fi
    done

    if [ -n "$MISSING_CMDS" ]; then
        MISSING_CMDS="$(echo "$MISSING_CMDS" | awk '{$1=$1};1')"
        MISSING_PKGS="$(echo "$MISSING_PKGS" | awk '{$1=$1};1')"

        cat << EOF
Your system is missing required commands:
 $MISSING_CMDS

Install them by running the following command:
 opkg install $MISSING_PKGS

EOF

        if [ -n "$INTERACTIVE" ]; then
            printf "Do you want to install them automatically? [Y/n]: "

            #shellcheck disable=SC2034
            read -r reply

            case "$reply" in
                [yY]*|"")
                    SCRIPT_BASE="/opt/tmp/pi-hole-install-deps"

                    cat <<EOT > "$SCRIPT_BASE.sh"
#!/bin/sh

printf "Waiting for opkg to finish..."

start_time=\$(date +%s)
while [ -f /opt/tmp/opkg.lock ] && [ \$(( \$(date +%s) - start_time )) -le 60 ]; do
    printf "."
    sleep 1
done

echo
opkg install $MISSING_PKGS
echo "Done!"

rm -f "\$0"
EOT
                    echo "Running install script in the background... ('tail -f $SCRIPT_BASE.log' for output)"
                    sh "$SCRIPT_BASE.sh" > "$SCRIPT_BASE.log" 2>&1 &
                ;;
            esac
        fi
    fi
else
    echo "Warning: Unable to check for missing dependencies - 'type' and 'which' commands not found!"
fi

# Set random gravity update and updatechecker times
if [ -f /opt/etc/cron.d/pihole ] && grep -q "59 1 \|59 17 " /opt/etc/cron.d/pihole; then
    MINUTE_GRAVITY="$(bash -c "echo \$((1 + RANDOM % 58))")"
    MINUTE_UPDATECHECK="$(bash -c "echo \$((1 + RANDOM % 58))")"
    HOUR_GRAVITY="$(bash -c "echo \$((3 + RANDOM % 2))")"
    HOUR_UPDATECHECK="$(bash -c "echo \$((12 + RANDOM % 8))")"

    echo "Setting random gravity update and updatechecker times..."

    if [ -n "$MINUTE_GRAVITY" ] && [ -n "$MINUTE_UPDATECHECK" ] && [ -n "$HOUR_GRAVITY" ] && [ -n "$HOUR_UPDATECHECK" ]; then
        sed "s/59 1 /$MINUTE_GRAVITY $HOUR_GRAVITY /" -i /opt/etc/cron.d/pihole
        sed "s/59 17 /$MINUTE_UPDATECHECK $HOUR_UPDATECHECK /" -i /opt/etc/cron.d/pihole
    fi
fi

# Set user and group used for rotating the logs by logrotate
if [ -f /opt/etc/pihole/logrotate ]; then
    #shellcheck disable=SC2010
    LOG_USER_GROUP="$(ls -al "/opt/var/log" | grep ' \.$' | awk '{print $3 " " $4}')"

    if [ -n "$LOG_USER_GROUP" ]; then
        echo "Setting user and group in logrotate file..."

        if grep -q "# su #" /opt/etc/pihole/logrotate; then
            sed "s/# su #/su $LOG_USER_GROUP/g;" -i /opt/etc/pihole/logrotate
        else
            sed "s/su.*$/su $LOG_USER_GROUP/g;" -i /opt/etc/pihole/logrotate
        fi
    fi
fi

# Gravity database file path
GRAVITYDB_FILE="$(pihole-FTL --config -q files.gravity)"

# Upgrade gravity database without rebuilding gravity
if [ -f "$GRAVITYDB_FILE" ]; then
    bash /opt/share/pihole/gravity.sh --upgrade
fi

# Restart the service when it is already running
if /opt/etc/init.d/S55pihole-FTL check | grep 'alive' > /dev/null 2>&1; then
    echo "Restarting pihole-FTL service..."
    /opt/etc/init.d/S55pihole-FTL restart
else # Otherwise just run the prestart script to set required permissions
    bash /opt/share/pihole/pihole-FTL-prestart.sh
fi

# Make sure gravity database exists
if [ -n "$GRAVITYDB_FILE" ] && [ ! -f "$GRAVITYDB_FILE" ]; then
    echo "Creating gravity database ($GRAVITYDB_FILE)..."
    bash /opt/share/pihole/gravity.sh --force
fi

# Update remote versions via updatechecker
# We cannot execute it now because opkg is running
{
    start_time=$(date +%s)
    while [ -f /opt/tmp/opkg.lock ] && [ $(( $(date +%s) - start_time )) -le 60 ]; do
        sleep 1
    done

    bash /opt/share/pihole/updatecheck.sh
} > /dev/null 2>&1 &

exit 0
