#!/bin/sh

# Check if this is an interactive console session
STDIN_FD="$(readlink -f /proc/$$/fd/0 2> /dev/null)"
[ -n "$STDIN_FD" ] && [ "$STDIN_FD" != "/dev/null" ] && INTERACTIVE=y

# If the UID 0 is not called root then we must add it to sudoers.d
ROOT_USER="$(id -nu 0 2> /dev/null)"
if [ -n "$ROOT_USER" ] && [ "$ROOT_USER" != "root" ]; then
    [ ! -d "/opt/etc/sudoers.d" ] && mkdir -p "/opt/etc/sudoers.d"
    cat <<EOT > "/opt/etc/sudoers.d/${ROOT_USER}_is_root"
# Created by pi-hole package's postinst script
$ROOT_USER ALL=(ALL) ALL
EOT
    chmod 600 "/opt/etc/sudoers.d/${ROOT_USER}_is_root"
fi

# Add 'pihole' user if it does not exist
if ! id "pihole" > /dev/null 2>&1; then
    if ! useradd -r -s /dev/null -d /dev/null pihole; then
        cat << EOF
Failed to add user 'pihole' using adduser command.
Some functionality might not be available without 'pihole' user in the system.
EOF

        if [ -n "$INTERACTIVE" ]; then
            cat << EOF

Retry by writing to the system files directly?

The following files will be APPENDED into:
 /opt/etc/passwd, /opt/etc/group, /opt/etc/shadow, /opt/etc/gshadow
Writing to these files directly is usually not recommended.

EOF

            printf "Do you wish to continue? [y/N]: "

            #shellcheck disable=SC2034
            read -r reply

            case "$reply" in
                [yY]*)
                    [ ! -f /opt/etc/passwd ] && { echo "/opt/etc/passwd is missing"; exit 1; }
                    [ ! -f /opt/etc/group ] && { echo "/opt/etc/group is missing"; exit 1; }
                    [ ! -f /opt/etc/shadow ] && { echo "/opt/etc/shadow is missing"; exit 1; }
                    [ ! -f /opt/etc/gshadow ] && { echo "/opt/etc/gshadow is missing"; exit 1; }

                    HIGHEST_UID=$(awk -F: '$3 >= 1000 {print $3}' /opt/etc/passwd | sort -n | tail -1)
                    NEXT_UID=1000

                    if [ -n "$HIGHEST_UID" ]; then
                        NEXT_UID="$(bash -c "echo \$(($HIGHEST_UID + 1))")"
                    fi

                    echo "pihole:x:$NEXT_UID:$NEXT_UID::/dev/null:/dev/null" >> /opt/etc/passwd
                    echo "pihole:x:$NEXT_UID:" >> /opt/etc/group
                    echo "pihole:*:0:0:99999:7:::" >> /opt/etc/shadow
                    echo "pihole:*::" >> /opt/etc/gshadow
                ;;
            esac
        fi
    fi
fi

# Make links to system files if they don't exist in /opt/etc
[ ! -f "/opt/etc/hosts" ] && [ -f "/etc/hosts" ] && ln -s "/etc/hosts" "/opt/etc/hosts"
[ ! -f "/opt/etc/ethers" ] && [ -f "/etc/ethers" ] && ln -s "/etc/ethers" "/opt/etc/ethers"
[ ! -f "/opt/etc/resolv.conf" ] && [ -f "/etc/resolv.conf" ] && ln -s "/etc/resolv.conf" "/opt/etc/resolv.conf"

# Set random gravity update and updatechecker times
if [ -f "/opt/etc/cron.d/pihole" ]; then
    MINUTE_GRAVITY="$(bash -c "echo \$((1 + RANDOM % 58))")"
    MINUTE_UPDATECHECK="$(bash -c "echo \$((1 + RANDOM % 58))")"
    HOUR_GRAVITY="$(bash -c "echo \$((3 + RANDOM % 2))")"
    HOUR_UPDATECHECK="$(bash -c "echo \$((12 + RANDOM % 8))")"

    if [ -n "$MINUTE_GRAVITY" ] && [ -n "$MINUTE_UPDATECHECK" ] && [ -n "$HOUR_GRAVITY" ] && [ -n "$HOUR_UPDATECHECK" ]; then
        sed "s/59 1 /$MINUTE_GRAVITY $HOUR_GRAVITY /" -i "/opt/etc/cron.d/pihole"
        sed "s/59 17 /$MINUTE_UPDATECHECK $HOUR_UPDATECHECK /" -i "/opt/etc/cron.d/pihole"
    fi
fi

# Set user and group used for rotating the logs by logrotate
if [ -f "/opt/etc/pihole/logrotate" ]; then
    #shellcheck disable=SC2010
    LOG_USER_GROUP="$(ls -al "/opt/var/log" | grep ' \.$' | awk '{print $3 " " $4}')"

    if [ -n "$LOG_USER_GROUP" ]; then
        if grep -q "# su #" "/opt/etc/pihole/logrotate"; then
            sed "s/# su #/su $LOG_USER_GROUP/g;" -i "/opt/etc/pihole/logrotate"
        else
            sed "s/su.*$/su $LOG_USER_GROUP/g;" -i "/opt/etc/pihole/logrotate"
        fi
    fi
fi

# Run updatechecker to update /opt/etc/pihole/versions
pihole updatechecker > /dev/null 2>&1

# Some of these commands might be missing depending on the system
# so we check if they exist and then prompt the user to install them
COMMAND_DEPS="su:shadow-su setcap:libcap-bin killall:psmisc pgrep:procps-ng-pgrep tput:libncurses-dev rev lscpu"
COREUTILS_DEPS="basename cat chmod chown cp cut date df dirname echo expr false head id install kill ln ls mkdir mktemp mv nohup printf pwd rm sha1sum sleep stat stty tail tee test timeout touch tr true tty uptime whoami"

CHECK_COMMAND=""
type 2> /dev/null && CHECK_COMMAND="type"
which --help > /dev/null 2>&1 && CHECK_COMMAND="which"

if [ -n "$CHECK_COMMAND" ]; then
    MISSING_CMDS=""
    MISSING_PKGS=""

    for COMMAND in $COMMAND_DEPS; do
        if echo "$COMMAND" | grep -q ":"; then
            PACKAGE="$(echo "$COMMAND" | cut -d ':' -f 2 2> /dev/null)"
            COMMAND="$(echo "$COMMAND" | cut -d ':' -f 1 2> /dev/null)"

            echo "$COMMAND" | grep -q ":" && continue # no 'cut' command?
        else
            PACKAGE="$COMMAND"
        fi

        #shellcheck disable=SC2086
        if ! $CHECK_COMMAND $COMMAND > /dev/null 2>&1; then
            MISSING_CMDS="$MISSING_CMDS $COMMAND"
            MISSING_PKGS="$MISSING_PKGS $PACKAGE"
        fi
    done

    for COMMAND in $COREUTILS_DEPS; do
        #shellcheck disable=SC2086
        if ! $CHECK_COMMAND $COMMAND > /dev/null 2>&1; then
            MISSING_CMDS="$MISSING_CMDS $COMMAND"
            MISSING_PKGS="$MISSING_PKGS coreutils-$COMMAND"
        fi
    done

    if [ -n "$MISSING_CMDS" ]; then
        MISSING_CMDS="$(echo "$MISSING_CMDS" | awk '{$1=$1};1')"
        MISSING_PKGS="$(echo "$MISSING_PKGS" | awk '{$1=$1};1')"

        cat << EOF
Your system is missing required commands:
 $MISSING_CMDS

Install them by running the following command:
 opkg install $MISSING_PKGS

EOF

        if [ -n "$INTERACTIVE" ]; then
            printf "Do you want to install them automatically? [Y/n]: "

            #shellcheck disable=SC2034
            read -r reply

            case "$reply" in
                [yY]*|"")
                    SCRIPT_BASE="/opt/tmp/pi-hole-install-deps"

                    cat <<EOT > "$SCRIPT_BASE.sh"
#!/bin/sh

printf "Waiting for opkg to finish..."

start_time=\$(date +%s)
while [ -f /opt/tmp/opkg.lock ] && [ \$(( \$(date +%s) - start_time )) -le 60 ]; do
    printf "."
    sleep 1
done

echo
opkg install $MISSING_PKGS
echo "Done!"

rm -f "\$0"
EOT
                    echo "Running install script in the background... ('tail -f $SCRIPT_BASE.log' for output)"
                    sh "$SCRIPT_BASE.sh" > "$SCRIPT_BASE.log" 2>&1 &
                ;;
            esac
        fi
    fi
else
    echo "Warning: Unable to check for missing dependencies - 'type' and 'which' commands not found!"
fi

exit 0
